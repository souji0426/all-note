\documentclass[C:/math/note-logic-intro/note]{subfiles}

\begin{document}


この章は文論理が対象である.
ではそもそも\textgtbf{sentential logic}{文論理}とはなにものだろうか？
\index{ぶんろんり@文論理}\index{sentential logic}
さらに何を学べば文論理を学んだことになるのか？
またこれ以降に登場する一階述語論理（もっといえば他の論理と）とは何が違うのか・何が共通しているのか？
そもそも論理を対象にした学問は何をやるべきなのだろうか？
これには私はまだ自分の言葉で答えることはできない.
よって私が好きな本である\cite{Logic003}から引用する.
論理学がどのような学問なのかという問いにはこの本の1章にて多くの言葉を用いて答えている.
続く2章にて1章で説明したような学問である（現代）論理学がなぜ人工言語を用いるのかが最初から書いてある.
全てを引用すると長くなるので大事な部分だけ17ページから引用するならば（句読点はこちらに合わせたが,
強調は引用元まま）
\begin{itemize}
 \item[]
   「\textgt{自然言語では命題の論理形式が文法形式におおい隠されてしまうことがある}.
   したがって,
   自然言語をそのまま使って論理学を展開することは得策ではない.
   これに対し,
   記号論言語は,
   命題内容に気を取られずにその形式を浮かび上がらせるのに好都合だ.
   なぜなら,
   記号言語はこれから作るのだから,
   我々の目的に応じて好きにつくってよいからだ.
   自然言語を使って我々はいろいろなことをやっている.
   その様々な用途のうち,
   「\textgt{論証の妥当性とは何かを明確にする}」という目的だけに役立るように思い切って単純化した言語をつくってしまえばいいわけだ.
\end{itemize}

さらにこの本によれば「現代論理学とは記号論理学ともよばれるくらいにやたらと記号を使う」とある.
すなわち「○○論理」という対象があったとき,
それが記号論理学の対象ならば,
上記にあるようにその論理を検証するのに最適な人工言語を用意するところから始まる.
また二つの全く別な論理という対象があったとき,
この論理たちの最大の違いはその言語にある（と思われる）.
だからこそ上記の本でも「命題論理（このテキストでいう文論理のこと）」という言葉が初めて導入されるのは,
一階述語論理という二つ目の人工言語が登場し,
それとの違いを比較できるようになってからだ. \\
改めて先の問いに答えると「そもそも文論理とはなにものだろうか？」には他の論理と比較することで初めて答えれるようになると思われる.
もちろんこの時点で上記の本を参考にして「単純命題の内部構造は問わない論理」と（単純命題とは何かを説明したうえで）答えることもできるが,
これはやはりそうでない論理と比較して初めてより分かりやすい答えに近づくと思われる.
続いて「何を学べば文論理を学んだことになるのか？」に答えると,
まずは文論理に適した言語を定め,
さらにその言語について構文論・意味論を定める.
記号論理学もしくは数理論理学ならばそこからさらに演繹体系を定める.
そして構文論・意味論・演繹体系それぞれに関する数学的な定理や,
それらを横断するような（たとえば完全性定理など）数学的な定理を証明していくことになる.
このステップを踏めば文論理について学んだことになると思われる.
そして最後の問い「これ以降に登場する一階述語論理（もっといえば他の論理と）とは何が違うのか・何が共通しているのか？」に答えるならば,
まず共通しているのは1つ上の問いの答えにあるステップの踏み方であると思われる.
もちろん言語によって出てくる定理の数や内容は異なるであろうが,
テキストの進め方は順番を除いて共通している（と個人的経験から推測する）.
そして異なる点は先にも述べた通り,
議論の最初に用意する人工言語になると思われる. \\

学ぶ動機などについてもう一度再確認した理由は,
例えばこのテキストでは文論理から一階述語論理へと進むが,
その際に用意する言語には共通の名前（たとえば整式など）を用いることがある.
つまり整式といったときどの論理の（ないし言語の）整式なのか意識する必要があると思われた.
そして例えば「これは文論理の整式だ」と書くときに,
「ではその文論理とは？」と聞かれたときに答える用意も必要に思われた.
もちろん自分できちんと答えたわけでもないし,
明確に答えたわけでもないが,
勉強会の参加者へ道しるべは示せたと思う.
数理論理学の数学的な分析・議論が目的の1つである当勉強会においていささか寄り道に思われる話題ではあったものの,
（数学的な議論ではないにしろ）参加者へ向けて答える必要があったのでここに書いておいた. \\

ではここから定義する言語についての定義や定理にはすべて「文論理の」という言葉がつくことを注意しておく. \\

まずはこれから使う記号という単語を定義する.

\begin{definition}[記号(E:p13~14,\ K:p20)]
  \label{definition:記号}
 互いに区別できる無限個のオブジェクトの列を用意し固定する.
 その列の成分となっているオブジェクトをそれぞれ\textbfgt{symbol}{記号}とよぶ. \\
 \index{ぶんろんり@文論理!きごう@記号}\index{sentential logic!symbol}
 \index{きごう@記号}\index{symbol}
 これらの記号のどれもが他の記号の有限な長さの列とは一致しないと仮定したうえで,
 列の第一成分から以下の表の通りに記号に名前をつける.
 \begin{table}[H]
     \begin{center}
       \begin{tabular}{c|l|l}
         \hline
         記号              & 名称        & 注意                         \\ \hline
         $($               & \textbfgt{left parenthesis}{左括弧}          & 区切り記号                  \\
         $)$               & \textbfgt{right parenthesis}{右括弧}         & 区切り記号                  \\
         $\lnot$           & \textbfgt{negation symbol}{否定記号}         & 日本語でいう「〜でない」     \\
         $\land$           & \textbfgt{conjunction symbol}{連言記号}      & 日本語でいう「かつ」         \\
         $\lor$            & \textbfgt{disjunction symbol}{選言記号}      & 日本語でいう「（包含的な）または」    \\
         $\to$             & \textbfgt{conditional symbol}{条件記号}      & 日本語でいう「○○ならば××」            \\
         $\leftrightarrow$ & \textbfgt{biconditional symbol}{双条件記号}  & 日本でいう「○○のとき, かつ, そのときに限り×× \\
         $A_1$             & $1$個目の\textbfgt{sentence symbol}{文記号}  &                            \\
         $A_2$             & $2$個目の\textbfgt{sentence symbol}{文記号}  &                            \\
         $\dots$           &                                             &                            \\
         $A_n$             & $n$個目の\textbfgt{sentence symbol}{文記号}  &                            \\
         $\dots$           &                                             &                            \\ \hline
       \end{tabular}
     \end{center}
     \caption{(E:p14 TABLE \glTwo,\ K:p21 表 \glTwo)}
     \label{table:文論理の記号}
   \end{table} \qedhere
   \index{ぶんろんり@文論理!ひだりかっこ@左括弧}\index{sentential logic!left parenthesis}
   \index{ひだりかっこ@左括弧}\index{left parenthesis}
   \index{ぶんろんり@文論理!みぎかっこ@右括弧}\index{sentential logic!right parenthesis}
   \index{みぎかっこ@右括弧}\index{right parenthesis}
   \index{ぶんろんり@文論理!ひていきごう@否定記号}\index{sentential logic!negation symbol}
   \index{ひていきごう@否定記号}\index{negation symbol}
   \index{ぶんろんり@文論理!れんげんきごう@連言記号}\index{sentential logic!conjunction symbol}
   \index{れんげんきごう@連言記号}\index{conjunction symbol}
   \index{ぶんろんり@文論理!せんげんきごう@選言記号}\index{sentential logic!disjunction symbol}
   \index{せんげんきごう@選言記号}\index{disjunction symbol}
   \index{ぶんろんり@文論理!じょうけんきごう@条件記号}\index{sentential logic!conditional symbol}
   \index{じょうけんきごう@条件記号}\index{conditional symbol}
   \index{ぶんろんり@文論理!そうじょうけんきごう@双条件記号}\index{sentential logic!biconditional symbol}
   \index{そうじょうけんきごう@双条件記号}\index{biconditional symbol}
   \index{ぶんろんり@文論理!ぶんきごう@文記号}\index{sentential logic!sentence symbol}
   \index{ぶんきごう@文記号}\index{sentence symbol}
\end{definition}
\RegisterInSymbolList{$($}{文論理の左括弧記号}{definition:記号}
\RegisterInSymbolList{$)$}{文論理の右括弧記号}{definition:記号}
\RegisterInSymbolList{$\lnot$}{文論理の否定記号}{definition:記号}
\RegisterInSymbolList{$\land$}{文論理の連言記号}{definition:記号}
\RegisterInSymbolList{$\lor$}{文論理の宣言記号}{definition:記号}
\RegisterInSymbolList{$\to$}{文論理の条件記号}{definition:記号}
\RegisterInSymbolList{$\leftrightarrow$}{文論理の双条件記号}{definition:記号}
\RegisterInSymbolList{$A_n$}{文論理の$n$番目の文記号}{definition:記号}


ここでテキストにあるものも含めていくつか注意を述べる.
順番や内容はテキストとは異なっている.
\begin{enumerate}
 \item
   \tablename\ \ref{table:文論理の記号}の「$($」や「$)$」における注意事項「区切り文字」について \\
   これはこの記号を区切り文字として使うということである.
   区切り文字とは日常言語における「,」や「、」のことで,
   文の読みやすさや文意が伝わりやすくするために用いる文字のことである.
   すなわちこの文論理の言語においては読みやすくするために「$($」や「$)$」を使うということである.
   %あとで書く
   \begin{comment}
     一階述語述語論理において区切り文字がどのような扱いになっているか分かったら補足すること.
   \end{comment}
 \item
   \tablename\ \ref{table:文論理の記号}の「$\lor$」の注意事項における「包含的な」について \\
   これは日本語における「または」にも排他的なものと包含的なものと二種類あり,
   この場合の「または」はそのうちの包含的なものの方であるという意味である.
   排他的な「または」とは,
   つなげられた2つの主張が同時に満たされることのない「または」の用法である.
   たとえば「このランチにはコーヒーまたは紅茶がつきます」といったときの「または」を聞いてコーヒーと紅茶両方を注文する人はいない.
   つまり注文者はこの「または」を聞いてどちらか1つだけしかもらえないことを理解しているのである.
   一方銀行ATMでの通帳とカードのどちらでもできる操作（たとえば入金とか）において「通帳またはカードを入れてください」といわれたとき,
   片方だけでも両方入れても同じように動作する（もちろん記帳するかどうかの結果は違いはあるかもしれないけれど）.
   よってこのときの「または」は包含的な方の「または」である.
   \footnote{
     とはいえ昔とある銀行ATMに同じように案内されて通帳とカード両方を入れてみたら「最初からやりなおしてください」と言われたことがあったり.
     つまりこの機械はおそらくいまでは珍しい？排他的なATMだった.
   }
 \item \textgt{いくつかの記号の総称について} \\
   \tablename\ \ref{table:文論理の記号}の中の5つの記号$\lnot,\lor,\land,\to,\leftrightarrow$を\textbfgt{sentential connective symbol}{文結合記号}とよぶ.
   \index{ぶんろんり@文論理!ぶんけつごうきごう@文結合記号}\index{sentential logic!sentential connective symbol}
   \index{ぶんけつごうきごう@文結合記号}\index{sentential connective symbol}

   とくに$\lor,\land,\to,\leftrightarrow$たちを\textgt{2項結合記号}とよぶ.
   \index{ぶんろんり@文論理!にこうけつごうきごう@2項結合記号}
   \footnote{
     テキストでは定義していない言葉でしたが,
     なんとなく意味はわかるし不要かとも思ったけどもあえて定義しておきました.
     また$\lnot$は1項結合記号とよぶべきかもですが,
     そんな記号は1つしかないため,
     そのような総称は必要ないと判断しました.
   }

   さらに括弧記号2つを総称して単に\textgt{括弧記号}とよぶ.
   \index{ぶんろんり@文論理!かっこきごう@括弧記号}
   \footnote{
     これも2項結合記号同様テキストでは定義していない言葉ではあるけれど,
     なんとなく意味はわかるし不要かとも思ったけどもあえて定義しておいた.
   }

   括弧記号と文結合記号をあわせて\textbfgt{sentential connective symbol}{論理記号}とよぶ.
   \index{ぶんろんり@文論理!ろんりきごう@論理記号}\index{sentential logic!sentential connective symbol}
   \index{ろんりきごう@論理記号}\index{sentential connective symbol}

   文記号は\textbfgt{parameter}{パラメータ}（または\textbfgt{nonlogivcal symbol}{非論理記号}）ともよぶ.
   \index{ぶんろんり@文論理!ぱらめーた@パラメータ}\index{sentential logic!parameter}
   \index{ぱらめーた@パラメータ}\index{parameter}
   \index{ぶんろんり@文論理!ひろんりきごう@非論理記号}\index{sentential logic!nonlogivcal symbol}
   \index{ひろんりきごう@非論理記号}\index{nonlogivcal symbol}

   また文記号$A_n$を{\boldmath n}\textgt{番目の命題記号}とよぶこともある.
   個人的にはこのテキストのように文論理ではなく命題論理の方がよくみてきたものではあるが,
   このテキストに従い命題記号という単語は使わず文記号とよぶことにする.
   \footnote{
     テキストに書いてある命題記号の方の呼び名を使いたい理由はさておき,
     このノートの説明事項（\pageref{remark:このノートに関する注意事項}）にも書いた通り,
     新たに自分で証明した内容についてはproposition（命題）やcorollary（系）など名前と番号を付けていくことになっています.
     とくにpropositionは訳すと「命題」なため「命題」を対象の名前につける数理論理学とは相性が悪いのかもしれません.
     ただここでのpropositionは証明すべき主張にしか使わないようにして,
     このノートでは他の定義や定理たちと同じように下線を引いていたり太字になっていたりするので紛らわしさはないから,
     併用しても問題はないと思います,
     脚注部分のような理由で「命題記号」という言葉は使わないようにしておきます.
   }
 \item \textgt{「互いに区別できる」部分について} \\
   ここでの「互いに区別できる」とは数学用語ではなく日常言語的な意味であろう.
   ではどのような意味で用いられているかと考えると,
   「それらの記号の運用者によって区別ができる」と意味であると思われる.
   この運用者とは今まさに紙とペンを持って記号を書きながら勉強している私たちのことかもしれないし,
   文論理の言語をプログラミング言語のように実装されたマシン（とそれを処理するアプリケーション）のことを指している.
   \footnote{
     とは書いてみたもののあまり自信がありません.
     なぜなら人によって区別できない記号って「字が汚い」場合以外どんなことがあるのだろうかと.
     でも外国人からすると日本語の漢字の似たものの区別はつきにくいとも聞くし,
     そんな場合を指しているのだろうか.
     よくよく考えると数学の手書きの議論において小文字と大文字の$c$は同時に使うことを避けるか,
     どちらかにアレンジを加えると思われるので,
     こういうときに区別がつきにくい記号の用意の仕方といえるのかも.
     でもマシンによって区別がつきにくい記号とはいったいなんなのだろうか.
     画像認識しながら数学をやっている機械ならまだしも,
     それだって画像の解像度や画像処理アプリの性能の問題だと思うし.
   }
 \item \label{remark:symbolの定義のオブジェクトについて}
   \textgt{オブジェクトについて} \\
   このオブジェクトとはテキストにある通りなんでもよく文論理の展開には無限個あるならばなんでもよいと思われる.
   \footnote{
     そういう意味ではテキストに書いてある通りおはじきは,
     現実のものに限れば無限個用意できないため不適と思いました.
     仮に無限個用意できても別の注意にある「互いに区別できる」部分が人にとっては難しそうに感じました.
     日本語での色の名前が有限しかない（\cite{Wiki005}）ことから,
     人間が見分けできる色が高々有限種類しかないのでは？
     名前のない色はRGB値で表現できるのかもしれないけれどそれでもたかだけ有限でしょう？（$256^3$くらい？）
     また色以外で違いをつけようにも大きさや形にも限度はあろうし.
     まぁ野暮なツッコミかもしれません. \\
     そんなことをする人がいたらかなり変人だと思うが,
     文論理の言語にある記号をオブジェクトとして使ってもいいと思う.
     そのままの対応では当たり前すぎるので例えば記号「$($」に「$A_1$」を割り当てるといったように.
     これもやってもよいとはいってもやる人はまずいないと思うかなり天邪鬼な例え話.
   }
   文論理の展開とは今テキストでやっていることを「実装する」ということを意味している.
   実装するとはすなわちこの文論理の記号たちとそれの使い方などを,
   プログラミング言語を用いて別のプログラミング言語を作るように実装するといったことを意味する.
   べつにプログラミング言語同士の話だけでなく例えば「$ZFC$から自然数論を展開可能」ということを簡単に証明するときに,
   集合（のように人間にとって思われる）という$ZFC$におけるオブジェクトを使ってペアノの公理を満たす集合たちとその上の演算や述語を作って自然数（と人間にとって思われている）を構成する作業も,
   その作業が似ていることから「$ZFC$における自然数論の実装」ともよべるだろう. \\
   自然数を使った文論理の簡単な（雑な）実装方法を挙げると,
   自然数列$0,1,2,3,\dots$を用意して,
   $0,1$に括弧記号,
   $2$から$6$に論理記号,
   $7$以降にパラメータを割り振る.
   \footnote{
     運用者が人間の場合は,
     その自然数をその記号だと「思い込む」「頭の中では数を記号に変換する」といった方がいいだろうか.
     マシンだとその対応でもって変換してくれるアプリケーションを用意するといった感じだろうか.
   }
   すると記号列$\op{\lnot}{A_2}$は対応した自然数が並んだ$\op{2}{9}$となる.
   つまり人にとっては単なる数字の羅列ではあるが,
   その解釈は私たちにとって目的としている文論理の記号列と思うわけである. \\
   こういうことは世の中にありふれたことだと思われる.
   現代のコンピュータは$0,1$のバイナリ情報しかやりとりできない（と思うことができる）わけで,
   \footnote{
     もちろん3進法コンピュータとかもあるんだろうけどあんまり聞かないし…
     だからここらへんの例え話もコンピュータに関する教養が足りず少し自信がありません.
   }
   画像ファイルも音楽ファイルも$0,1$が大量に書き込まれたテキストファイルでしかなく,
   どのアプリで開くかによって出力が変わってくる（だからこそどのアプリで開くべきかを教えてくれる拡張子に存在意義がある）. \\
   そうなると$\op{2}{9}$と$\langle 29 \rangle$は人間にとってはかなり見分けがつきにくいが,
   機械にとってそもそも列の成分数も違うことから簡単に見分けがつき,
   そしてその記号の解釈も別のものになる（この実装方法で行くと$\langle 29 \rangle$は$22$番目の文記号$A_{22}$となるから）. \\
   集合による実装は,
   まず集合論内の議論によって自然数を構築する.
   よく知られた方法としては順序数理論を展開し順序数の中でも特別なものを自然数とする方法である.
   %あとで書く
   \begin{comment}
     公理的集合論の服種をやったときに順序数としての自然数の定義が終わったらここの脚注に引用する.
   \end{comment}
   すると集合としての自然数を得ることができたので,
   それを使って（雑なものでよければ）さきの自然数を使ったものと同様にすればよい. \\
   大事なことはこのテキストでは,
   定義にある条件をみたしていればどのようなオブジェクトが使われているか,
   もしくはどのようなオブジェクトで実装されているかは意識しないし,
   またそれに依存しない理論の話が続いていく. \\
   ではなぜするかどうかも分からない「実装する上での注意」なんて著者は併記したのだろうか？
   それはつまり実際に自然数論や集合論を使って文論理の理論を展開することがあるからである.
   %あとで書く
   \begin{comment}
     このテキストで後々そういう話をするのでそこまで読み進めたあとに引用する.
     具体的には自然数論や集合論を使って文論理の理論を展開するところまで読んだらの話.
   \end{comment}
   また今後記号が割り振られたオブジェクトとその記号をとくに区別せず割り振られた方の記号を使って使っていく.
   つまり仮に自然数を使って上記のように実装したとしていても,
   オブジェクトとしての$0$は使わず,
   それに割り振られた記号「$($」を議論のさいには使っていくということである.
 \item \textgt{「無限個のオブジェクトの列」部分と「列の第一成分から」部分について}
       \label{remark:symbolの定義の「無限個のオブジェクトの列」部分と「列の第一成分から」部分について} \\
   単に「無限個のオブジェクト」でも問題なさそうに見えるが,
   なぜ「無限個のオブジェクト\textgt{の列}」としたのだろうか.
   これも注意事項\ \ref{remark:symbolの定義のオブジェクトについて}と同じように実装上の注意事項だろうと思われる.
   列にすると並んだ記号たちに$0$から自然数を全て使って番号が付属していると思える.
   それこそ数学における数列やプログラミングにおけるハッシュ関数の返り値のように.
   \footnote{
     プログラミングを知っている人に向けて用意した例え話なのだけれど,
     もしかしたらハッシュを使えないプログラミング言語ってあったりするのかな.
     かりに基本文法になかったとしてもライブラリや自作関数などで対応できそうだけれども.
     ちなみにハッシュ関数という言葉はWikipedia『ハッシュ関数』\cite{Wiki006}より拝借した
     （自分は普段は単にハッシュと呼んでるけれども）.
   }
   もし使いたい記号（というかその概念や名称）が有限個しかない言語ならば,
   無限個のオブジェクトも要らず,
   また列でないなくともよいのかもしれない.
   しかし今から私たちが用意したい記号は無限個の文記号を含むため,
   オブジェクトも無限個必要である.
   よってそんな文記号用に無限の空きが必要なので,
   さきに有限個で済む文記号以外をオブジェクトの番号の小さいものから割り当てていき,
   残った無限個のオブジェクトにその番号が小さいものから文記号についている番号の小さいもの順に割り当てていく.
   そうすれば一番分かりやすいと思われるため,
   だからこそDefinition \ref{definition:記号}においても「列の第一成分から」とテキストにはないものを追加した.
   1つ上の注意に書いた通り実装方法にはこだわらないのだから別にこの注意は不要でもあるのだが,
   この時点で勉強会で話した「お気持ち」を伝えるためにも付記しておいた. \\
   また別の実装方法もいくつも存在することを注意しておく.
   自然数を用いた実装方法として$0,1,2,3,\dots$を使って,
   それぞれに$(,A_1,),A_2,\lnot,A_3,\land,A_4,\lor,A_5,\to,A_6,\leftrightarrow,A_7,A_8,\dots$と実装してもよい.
   だがこれよりは最初の例の方が分かりやすいし実装しやすいとも思われる.
 \item \label{remark:symbolの定義の「これらの記号のどれもが他の記号の有限な長さの列とは一致しない」部分}
   \textgt{「これらの記号のどれもが他の記号の有限な長さの列とは一致しない」部分について} \\
   この条件も注意事項\ \ref{remark:symbolの定義のオブジェクトについて}と同じように実装上の注意事項だろうと思われる.
   例えばExample \ref{example:集合として一致するが長さが異なる有限列}に出したものを使って,
   こちらで用意したオブジェクトの列を（有限ではあるがいまは気にしない）$\langle 0,1,\op{0}{1},\op{0,1}{0}\rangle$として,
   これに$\lnot,\to,A_1,A_2$を割り当ててたとすると,
   $A_1=\op{0}{1}=\op{\lnot}{\to},\ A_2=\op{0,1}{0}=\op{\lnot,\to}{\lnot}$となってしまい,
   $S_1=\op{\op{0,1}{0}}{1}=\op{A_2}{\to}\ ,S_2=\op{\op{0}{1},0}{1}=\langle A_1,\lnot,\to\rangle$となる.
   つまり意図としては列$S_1,S_2$は異なる列であってほしいが,
   この列を集合として扱う運用者からすれば,
   この2つの列は集合として一致しているので同じものとして扱わなくてはいけない.
   よってこのようなことが起こらないためにはこの条件は必要である.
   この条件と\LemRef{lemma:長さの違う有限列が一致するとき始切片で帳尻が合う}や\ExRef{example:集合として一致するが長さが異なる有限列}の議論もあわせて,
   もし2つの記号の列が$\ntuple{a_1}{a_m}=\ntuple{b_1}{b_n}$でDefinition \ref{definition:記号}の条件をみたす記号ならば,
   $m=n$かつ$a_i=b_i$となる.
 \item
   \textgt{無限の文記号を用意しない方法} \\
   テキストでは無限個の文記号を使う以外の方法が提示されている.
   1個の文記号$A$とプライム記号$\prime$を使って$A_1,A_2,A_3,\dots$の代わりに$A,A^{\prime},A^{\prime\prime},\dots$とするのである.
   こうするとたった2個の記号の無限個の記号を用意することができる.
   これはなるべくコンパクトな定義をしようとするならば良い方法に思われる.
   ただ実装するときになると各文記号に「$A$にどれだけのプライム記号をつけたのか」という情報を追加しなくてはならないようにも思えるので,
   どれほど他の実装方法と比べて楽になるのかはこの時点では分からない. \\
   今後議論するときに「任意の文記号をとる」ということをするが,
   そのさいにその任意に取った文記号を表すための記号として$A_1,A_2,\dots$などは使えないので,
   $A$や$A_n$または$A^{\prime}$などを使うことにする.
   ちなみに$A_n$は定義を書くためのメタ的な表現であって実際に$n$という文字を使った$A_n$のような記号は文論理の記号ではない.
 \item
   \textgt{オブジェクトの数について} \\
   この定義によると文記号として用意すべきは可算無限個のオブジェクトが必要である.
   そして文記号以外の記号（つまり論理記号）の数は有限なので全ての記号を定めるのに必要な個数は結局可算無限個で十分である.
   しかし可算無限個でなくてはいけないというわけではない.
   例えば文記号全てを濃度が可算より大きい集合$\mathbb{R}$を使って定めてもよい.
   つまり各実数を文記号だと扱うわけである.
   %あとで書く
   \begin{comment}
     文記号の集合が不可算になったときにどのような弊害があるのか分かれば,
     ここに引用する.
   \end{comment}
\end{enumerate}

テキストにはないが便利のため以下の記法を用意しておく.

\begin{notation}
  \label{notation:文記号の集合}
  その文論理の文記号の集合を$\SetOfSentenceSymbol$で表す.
\end{notation}
\RegisterInSymbolList{$\SetOfSentenceSymbol$}{文論理の文記号の集合}{notation:文記号の集合}

上の注意事項より何が文記号なのかはその時の議論によって変わるので,
$\SetOfSentenceSymbol=\{ A_0, A_1,A_2,\dots \}$や$\SetOfSentenceSymbol=\{ A,A^{\prime},A^{\prime\prime},\dots \}$となったりする.
また文記号は常に無限個用意されるので,
$\card( \SetOfSentenceSymbol ) \geq \aleph_0$である.

つぎに「表現」という言葉を定義するため,
以降日常言語としての表現は使わないよう気をつける.

\begin{definition}[表現(E:p15,\ K:p23)]
  \label{definition:表現}
 \DefRef{definition:有限列}の用語を用いる.
 \begin{itemize}
   \item[1.] 文論理の記号の集合を以降$\SetOfSymbol$で表すことにする.
   \item[2.]
     $\SetOfSymbol$の要素からなる有限列を\textbfgt{expression}{表現}とよぶ.
     \index{ぶんろんり@文論理!ひょうげん@表現}\index{sentential logic!expression}
     \index{ひょうげん@表現}\index{expression}

     またすべての表現の集合を$\SetOfExpression$で表すことにする. \\
     また表現$\ntuple{s_1}{s_n}$（ここで各$s_i$は$\SetOfSymbol$の要素である）をその成分を順番に並べて$s_1s_2\dots s_{n-1}s_n$と書くこともある.
     以降どちらの使い方も柔軟に使っていくことにする.
   \item[3.]
     $\alpha,\beta\in \SetOfExpression$に対してそれぞれ$\alpha=\ntuple{a_1}{a_m},\ \beta=\ntuple{b_1}{b_n}$とするとき,
     $\alpha\beta\defeq \langle a_1,\dots,a_m,b_1,\dots,b_n\rangle$として,
     これを$\alpha$と$\beta$の\textbfgt{string concatenation}{文字列連結}とよぶ.
     \index{ぶんろんり@文論理!もじれつけつごう@文字列結合}\index{sentential logic!string concatenation}
     \index{もじれつけつごう@文字列結合}\index{string concatenation}
     \footnote{
       これはテキストでは定義されていない言葉ではありますが,
       定義しておくと便利かと思ったのでプログラミングにおける文字列結合演算（例えば\cite{Wiki008}）を参考に定義しておきました.
     }
     \qedhere
 \end{itemize}
\end{definition}
\RegisterInSymbolList{$\SetOfSymbol$}{文論理の記号の集合}{definition:表現}
\RegisterInSymbolList{$\SetOfExpression$}{文論理の表現の集合}{definition:表現}

明らかに$\SetOfSentenceSymbol \subseteq \SetOfSymbol$であり,
$\SetOfExpression=\bigcup_{n\in \mathbb{N}}\SetOfSymbol^n$である.

表現の2通りの表し方についてだが当然私たちにとって分かりやすいのは$s_1s_2\dots s_{n-1}s_n$の方である.
だからその定義に踏み込んで議論する必要がないときには$s_1s_2\dots s_{n-1}s_n$の方を優先的に使っていく. \\

この文字列結合は$\SetOfExpression$上の2項演算,
つまり演算結果$\alpha\beta$も表現である.
またその意味もその名前のごとく$\alpha$の列の後ろに$\beta$の列をそのまま並べたものになっている.

\begin{example}[E:p15,\ K:p23]
 表現$\alpha,\beta$に対して
 \begin{enumerate}
   \item
     $(\lnot A_1)$という（私たちにとって見やすい表し方をした）表現は厳密には
     有限列$\langle (,\lnot,A_1,)\rangle$のことである.
   \item \label{remark:表現の結合と代入}
     $\alpha = (\lnot A_1),\ \beta=A_2$とおくと
     その文字列結合$\alpha\beta$は$(\lnot A_1)A_2$に,
     $(\alpha\to \beta)$は$((\lnot A_1)\to A_2)$となる. \qedhere
 \end{enumerate}
\end{example}

例の\ref{remark:表現の結合と代入}つ目における$((\lnot A_1)\to A_2)$とは,
$(\alpha\to \beta)$の$\alpha,\beta$部分にその表現を代入したものである.
Definition \ref{definition:表現}でも使ったが改めて注意すると,
$\alpha,\beta$は文論理の記号ではなく,
文論理について議論している表現を変数のように使いたいための私たちの記号である.
プログラミングでいうところのマクロのようなものともいえる.

\begin{definition}[式構成操作(E:p17,\ K:p25)]
  \label{definition:式構成操作}
 $\alpha,\beta\in \SetOfExpression$と論理記号に対して
 \begin{itemize}
   \item
     $\mathcal{E}_{\lnot}(\alpha)=(\lnot \alpha)$と定める.
     より厳密には$\mathcal{E}_{\lnot}(\alpha)\defeq \op{(}{\lnot}\alpha \singleseq{)}$であり,
     これはDefinition \ref{definition:表現}で定義した表現の文字列連結である.
     つまり$\mathcal{E}_{\lnot}$は$\SetOfExpression$上の1変数関数である.
   \item
   $\mathcal{E}_{\land}(\alpha,\beta)=(\alpha \land \beta)$と定める.
   より厳密には$\mathcal{E}_{\land}(\alpha,\beta)\defeq \singleseq{(} \alpha \singleseq{\land} \beta \singleseq{)} $であり,
   $\mathcal{E}_{\land}$は$\SetOfExpression$上の2変数関数である. \\
   同様にして$\SetOfExpression$上の2変数関数として$\mathcal{E}_{\lor},\mathcal{E}_{\to},\mathcal{E}_{\leftrightarrow}$を定義する.
 \end{itemize}
 これらの5つの演算をあわせて\textbfgt{formula-building operation}{式構成操作}とよぶ.
 \index{ぶんろんり@文論理!しきこうせいそうさ@式構成操作}\index{sentential logic!formula-building operation}
 \index{しきこうせいそうさ@式構成操作}\index{formula-building operation}
\end{definition}
\RegisterInSymbolList{$\mathcal{E}_{\lnot}$}{$\lnot$を付ける式構成操作}{definition:式構成操作}
\RegisterInSymbolList{$\mathcal{E}_{\land}$}{$\land$でつなげる式構成操作}{definition:式構成操作}
\RegisterInSymbolList{$\mathcal{E}_{\lor}$}{$\lor$でつなげる式構成操作}{definition:式構成操作}
\RegisterInSymbolList{$\mathcal{E}_{\to}$}{$\to$でつなげる式構成操作}{definition:式構成操作}
\RegisterInSymbolList{$\mathcal{E}_{\leftrightarrow}$}{$\leftrightarrow$でつなげる式構成操作}{definition:式構成操作}

\begin{definition}[（素朴な）整式の定義(E:p16~17,\ K:p25)]
  \label{definition:（素朴な）整式の定義}
 \textbfgt{well-formed formula}{整式}とは以下のように帰納的に定義される.
 \index{ぶんろんり@文論理!しせいしき@整式}\index{sentential logic!well-formed formula}
 \index{しせいしき@整式}\index{well-formed formula}
 \footnote{
   テキストでは単に「式（formula）」とか,
   原著だと「wff」などの呼び方も提示されていますが,
   個人的な理由で整式のみで統一しようと思います.
 }

 \begin{itemize}
   \item[(a)] 個々の文記号は整式である.
   \item[(b)] $\alpha,\beta$が整式ならば,
     $(\lnot \alpha), (\alpha \land \beta), (\alpha \lor \beta), (\alpha \to \beta), (\alpha \leftrightarrow \beta)$は整式である.
   \item[(c)] (a)(b)にあてはまるものだけが整式である. \qedhere
 \end{itemize}
\end{definition}

(b)はつまりすでに整式があったとき,
それらの式構成操作の結果もまた整式であると主張している. \\
この定義は別に数学的に間違っているわけではない.
しかしより厳密に定義することもできる.
そうしたとき式構成操作を$\SetOfExpression$上の関数として捉えることにも意味がでてくる. \\
簡単にいうと整式とは文記号から始めて式構成操作を有限回適用して構成できる表現のことと言えるが,
この「有限回適用して」の部分を構成列というものを使って厳密に定義できる.
%あとで書く
\begin{comment}
  何種類かの操作で「閉じさせる」という構成方法について\SecRef{section:帰納法と再帰}を読み終わって議論が分かれば,
  ここに引用しておく.
\end{comment}

\begin{definition}[構成列と整式(E:p17~18,\ K:p26~27)]
  \label{definition:構成列と整式}
 表現の集合$\SetOfExpression$の有限列$\ntuple{\varepsilon_1}{\varepsilon_n}$が\textbfgt{construction sequence}{構成列}であるとは,
 各$i\leq n$に対して(1)から(3)のいずれかをみたすときをいう.
 \index{ぶんろんり@文論理!こうせいれつ@構成列}\index{sentential logic!construction sequence}
 \index{こうせいれつ@構成列}\index{construction sequence}

 \begin{itemize}
   \item[(1)] $\varepsilon_i$は文記号.
   \item[(2)] ある$j<i$があって$\varepsilon_i=\mathcal{E}_{\lnot}( \varepsilon_j )$.
   \item[(3)] ある$j,k<i$があって$\varepsilon_i=\mathcal{E}_{\square}( \varepsilon_j, \varepsilon_k )$. \\
     ここで$\square$は2項結合記号のいずれかを表す.
 \end{itemize}

 ある表現$\alpha$で終わる（つまり末項が$\alpha$である）ような構成列が存在するとき,
 そんな表現を\textbfgt{well-formed formula}{整式}とよぶ.
 \index{ぶんろんり@文論理!しせいしき@整式}\index{sentential logic!well-formed formula}
 \index{しせいしき@整式}\index{well-formed formula}

 すべての整式の集合は今後$\SetOfWff$で表すことにする.
 \footnote{
   これもテキストではこの記号を与えたりはしていませんが,
   個人的に便利なことが多かったので定めておきました.
 }
\end{definition}
\RegisterInSymbolList{$\SetOfWff$}{文論理の整式の集合}{definition:構成列と整式}

明らかに$\SetOfWff \subseteq \SetOfExpression$である.

$\mathcal{E}_2$を2項結合記号の集合とするとき,
有限列$\ntuple{\varepsilon_1}{\varepsilon_n}$が構成列であることは論理式で
\begin{equation*}
 \forall i<n\big(\ \varepsilon_i\in \SetOfSentenceSymbol\ \lor\ \exists j< i( \varepsilon_i=\mathcal{E}_{\lnot}( \varepsilon_j ) )\ \lor\ \exists j,k< i\exists \square \in \mathcal{E}_2 ( \varepsilon_i=\mathcal{E}_{\square}( \varepsilon_j, \varepsilon_k )\ \big)
\end{equation*}
と書ける.
ここで$\mathcal{E}_{\square}$という書き方は直感的にはわかりやすいが,
まるで$\mathcal{E}_{\square}$という$\square$を変数とした関数のようにも見えてしまうので,
$\exists j,k< i\exists \square \in \mathcal{E}_2 ( \varepsilon_i=\mathcal{E}_{\square}( \varepsilon_j, \varepsilon_k )$の部分は本当は
\begin{equation*}
 \exists j,k< i\big(\  \varepsilon_i=\mathcal{E}_{\land}( \varepsilon_j, \varepsilon_k )\ \lor
  \ \varepsilon_i=\mathcal{E}_{\lor}( \varepsilon_j, \varepsilon_k )\ \lor
  \ \varepsilon_i=\mathcal{E}_{\to}( \varepsilon_j, \varepsilon_k )\ \lor
  \ \varepsilon_i=\mathcal{E}_{\leftrightarrow}( \varepsilon_j, \varepsilon_k )\ \big)
\end{equation*}
と書くべきだろうが,
ここで初めて$\mathcal{E}_{\lor}$に含まれている$\lor$と,
各論理式をつないでいる$\lor$とで記号の衝突が起きている.
これが頭の中で完全に区別できている人たちの中で,
議論のさいにこう書くなら問題はないが（それでも多分良い顔はしないと思うけれど）,
初学者には余計な誤解やそれによる遠回りを与える可能性がある.
ゆえにテキストでは（おそらく意図的に）一貫して（\ChapRef{chapter:集合についての予備知識}のような別に論理学に直接関係する概念でなくても）何かを定義するさいには,
日常言語で述べることにしたのであろう.

\begin{example}
  \label{example:構成列}
 整式$\alpha$を$(\ (A_1\land A_{10})\ \to\ (\ (\lnot A_3)\ \lor\ (A_8\leftrightarrow A_3)\ )\ )$とすると,
 以下の有限列は
 \begin{equation*}
   \langle\ A_1,\ A_3,\ A_8,\ A_{10},\ (A_1\land A_{10}),\ (\lnot A_3),\ (A_8\leftrightarrow A_3),\ ((\lnot A_3)\lor(A_8\leftrightarrow A_3)),\ \alpha\ \rangle
 \end{equation*}
 その構成列の一例である.
\end{example}

ここでテキストでは系統樹による説明がある（これより前から何度か登場しているけれど）.
\ChapRef{chapter:集合についての予備知識}によると木概念は非形式的な議論にしか使わないと書いてある.
つまり系統樹を使って説明されている事柄はすべて定義に戻ればより厳密な数学的議論をすることができるということなので,
このノートでは系統樹を使った説明は必要だと思ったときにします.
\footnote{
 決して系統樹を$\text{\LaTeX}$で書くのがめんどくさいとかそういうことではない……
 もちろん視覚的には系統樹の方が分かりやすいのは知っているのだけれど.
}

Example \ref{example:構成列}で私が書いた構成列には「先に使う文記号は列先頭からすべて書いておく」という個人的な好みが現れている.
だがある整式に対する構成列は1つではない.
例えば（私の好みに反する）以下のような（必要になったときに文記号を挿入するような）整式の有限列も
\begin{equation*}
 \langle\ A_1,\ A_{10},\ (A_1\land A_{10}),\ A_3,\ (\lnot A_3),\ A_8,\ (A_8\leftrightarrow A_3),\ ((\lnot A_3)\lor(A_8\leftrightarrow A_3)),\ \alpha\ \rangle
\end{equation*}
整式$\alpha$の構成列である. \\

ここからさらに（この時点で）テキストにない注意を例え話を入れながら追加する.
\begin{enumerate}
 \item
   たとえば整式$(A_1\land A_2)$の構成列として最も単純なものは$\langle A_1,A_2,(A_1\land A_2)\rangle$であろうが,
   別に$\langle A_2,A_1,(A_1\land A_2)\rangle$でもよい.
   つまり構成列の定義をみたす範囲で文記号が現れる順番を変えてもよい.
   また構成列の定義をみたす範囲で余計な整式を構成列に混ぜてもよい.
   たとえば
   \begin{gather*}
     S_1=\langle A_1,A_2,A_3,(A_1\land A_2)\rangle, \\
     S_2=\langle A_1,A_2,A_3,(\lnot A_3),(A_1\land A_2)\rangle
   \end{gather*}
   とおくと,
   $S_1, S_2$どちらも$(A_1\land A_2)$の構成列である.
   しかし$\langle A_1,A_2,A_3,(A_1\land A_2),A_3\rangle$は整式$A_3$の構成列である.
   さらに$\langle A_1,A_2,A_3\rangle$も$\langle A_3,A_3,A_3\rangle$も$A_3$の構成列である.
 \item
   ある構成列の始切片もまた構成列で,
   ゆえになんらかの整式に対応した構成列となる.
   例えば
   \begin{gather*}
     S^{\prime}_1=\singleseq{A_1}, \\
     S^{\prime}_2=\op{A_1}{A_2}, \\
     S^{\prime}_3=\langle A_1,A_2,A_3\rangle, \\
     S^{\prime}_4=\langle A_1,A_2,A_3,(\lnot A_3)\rangle
   \end{gather*}
   とおくと,
   それぞれ$S_2$の始切片で,
   $S^{\prime}_1$は$A_1$の,
   $S^{\prime}_2$は$A_2$の,
   $S^{\prime}_3$は$A_3$の,
   $S^{\prime}_4$は$(\lnot A_3)$の構成列である.
   これは単なる観察ではなく,
   つまりこの整式だけにあてはまる現象ではなくすべての整式に対して成立する.
   これは\PropRef{proposition:構成列の始切片は構成列}で示した.
 \item
   また例えば$\singleseq{A_1}$は$A_1$という整式の構成列であるが,
   1つ組の定義から$\singleseq{A_1}=A_1$でもあるから,
   $A_1$そのものは整式でもあり,
   かつ自分自身の構成列でもある.
   当然これは他の文記号に関しても同様である.
 \item
   $A_3,\ (\lnot A_3)$という$(A_1\land A_2)$に含まれていない文記号からなる整式を$S_2$から取り除いても,
   つまり構成列$\langle A_2,A_1,(A_1\land A_2)\rangle$は依然として$(A_1\land A_2)$の構成列のままである.
   例えば\ExRef{example:構成列の末項に含まれない文記号を含む整式をその構成列から除いても問題ない}にて,
   似たような問題を解いている.
   上記の事をより一般的に証明してみたいので,
   今後の課題としておく.
   \begin{kongo}
     ある整式の構成列があったとき,
     その末項整式に含まれていない文記号を持つ整式が,
     その構成列に含まれていた場合に,
     そのような整式全てを構成列から除いても,
     その末項整式の構成列であることには変わらない.
   \end{kongo}

 \item \label{remark:すべての整式に対しての構成の長さに関する証明の妥当性}
   またこの注意たちの前に整式に対応する構成列は1つではないと述べたが,
   もっといえば無数にある.
   例えば単に$A_1$という整式の構成列でも長さが2のものに限っても,
   $\op{A_1}{A_1},\ \op{A_2}{A_1},\ \op{A_3}{A_1},\dots$など無限にある.
   つまりある整式に対しての構成列は無限に存在するが,
   ある構成列はそれぞれ1つの整式に対応している.
   これを使えば「任意の整式に対して」という形の主張の証明に役立てることができる.
   どういうことかというと「任意の整式に対して○○」ということを示す代わりに,
   「任意の構成列に対して○○」を示してもよいということである.
   \footnote{
       これまでの観察により構成列の個数は整式の個数よりもはるかに多いため,
       この証明は整式に対して証明するものと加えるとかなり無駄が多いように思ってしまう.
       でも証明のやりやすさが上がることもあるし,
       まぁダブっていても足りなくなっていないのならばそれでOKなのだ. \\
       でも「任意の構成列に対して○○」という形の主張を示すときに,
       「任意の整式に対して○○」という主張を証明してはいけない.
       これは明らかに構成列をすべて取りつくしていないから,
       ということになる.
   }
   もちろん最初の○○部分が整式のみしか扱えないならば,
   それを構成列に関するものへ変更する必要はある. \\
   そして構成列は有限列ゆえにすべての構成列にはその「長さ」という情報が備わっている.
   これを利用して「任意の構成列に対して○○」を示す代わりに,
   「任意の長さの構成列に対して○○」を証明してもよい.
   こういう風に証明内容を変更する最大のメリットは長さという0より大きい自然数に対しての主張に変わったことにより,
   種々の自然数に関する帰納法を用いられるようになったことである.
   もっと具体的にどのように示すかというと「任意の$n\in \mathbb{N}$と構成列に対して,
   その構成列の長さが$n$ならば○○」を示す形になる.
   つまり証明の最初は任意に長さ$n$の構成列をとるところからはじまる. \\
   このほかにも表現や整式の単なる長さや整式に含まれる文記号の個数など,
   表現・整式に備わる様々な「数」を使って証明していくことになる.
 \item
   \DefRef{definition:（素朴な）整式の定義}にある定義を採用するテキストも多い.
   これのメリットとしては「任意の整式に対して○○」という主張に対して\textgt{構成に関する帰納法}を使うことができることである.
   構成に関する帰納法は\textbfgt{structural induction}{構造的帰納法}と呼ばれることもある.
   なので以降は（カッコいい方の）構造的帰納法という呼び名を使っていく.
   \footnote{
     この呼び方はWikipedia『構造的帰納法』\cite{wiki007}より知りました.
   }
   これは次の2つのことを示るやり方である.
   \begin{itemize}
     \item[]\hspace{-0.5cm}（Basis）
       すべての文記号が○○をみたすことを示す.
     \item[]\hspace{-0.5cm}（Induction step）
       整式$\alpha,\beta$が○○をみたしているとして,
       $(\lnot \alpha), (\alpha \land \beta), (\alpha \lor \beta), (\alpha \to \beta), (\alpha \leftrightarrow \beta)$が○○をみたしていることを示す.
   \end{itemize}
   証明すべきことの名前（Basisとかのこと）は\cite{Logic003}から拝借した.
   もちろん\cite{Logic003}では整式の定義は\DefRef{definition:（素朴な）整式の定義}と同じようになされている. \\
   ときどき余裕があればこちらのやり方でも証明してみることにする.
   もしかしたら主張によってはこちらの方が証明がやりやすくなることもあるかもしれない.
\end{enumerate}

では練習がてら色々と自分で簡単な主張を用意して証明してみる.

\begin{proposition}
  \label{proposition:構成列の始切片は構成列}
 構成列のどのその真の始切片もまた構成列である.
\end{proposition}

\begin{proof}
 証明すべきことは「任意にとった構成列に対して,
 さらに任意にその構成列の始切片をとると構成列になっている」である.
 任意に構成列をとるかわりに任意の長さの構成列をとることにすると証明目的は「任意にとった$n\in \mathbb{N}$と構成列に対して,
 その構成列の長さが$n$ならば,
 さらに任意にその構成列の始切片をとると構成列になっている」となる.
 この任意にとる$n$に対して,
 つまり構成列の長さに関して累積帰納法を使って示す.
 任意に$n\in \mathbb{N}$をとる.
 この帰納法の仮定は「長さが$n$未満であるような全ての構成列が,
 そのどの始切片も構成列になっている」である.
 いま任意に長さ$n$の構成列$\ntuple{\varepsilon_1}{\varepsilon_n}$をとり,
 さらにその真の始切片として$\ntuple{\varepsilon_1}{\varepsilon_m}$をとる.
 つまり$m<n$である.
 ここで$\varepsilon_m$は構成列$\ntuple{\varepsilon_1}{\varepsilon_n}$の成分の1つなので,
 \begin{itemize}
   \item[($1^{\prime}$)] $\varepsilon_m \in \SetOfSentenceSymbol$.
   \item[($2^{\prime}$)] $\exists j<m\big(\ \varepsilon_m=\mathcal{E}_{\lnot}( \varepsilon_j )\ \big)$.
   \item[($3^{\prime}$)] $\exists j,k<m\big(\ \varepsilon_m=\mathcal{E}_{\square}( \varepsilon_j, \varepsilon_k )\ \big)$.
     ここで$\square$は2項結合記号のいずれかを表す.
 \end{itemize}
 を満たしている.
 つまり「$\varepsilon_m$は($1^{\prime}$)または($2^{\prime}$)または($3^{\prime}$)をみたす」となっている. \\
 いま有限列$\ntuple{\varepsilon_1}{\varepsilon_{m-1}}$は$\ntuple{\varepsilon_1}{\varepsilon_m}$の真の始切片でかつ帰納法の仮定から構成列なので,
 任意の$i\leq m-1$に対して
 \begin{itemize}
   \item[($1^{\prime\prime}$)] $\varepsilon_i \in \SetOfSentenceSymbol$.
   \item[($2^{\prime\prime}$)] $\exists j<i\big(\ \varepsilon_m=\mathcal{E}_{\lnot}( \varepsilon_j )\ \big)$.
   \item[($3^{\prime\prime}$)] $\exists j,k<i\big(\ \varepsilon_m=\mathcal{E}_{\square}( \varepsilon_j, \varepsilon_k )\ \big)$.
     ここで$\square$は2項結合記号のいずれかを表す.
 \end{itemize}
 を満たしている.
 つまり「任意の$i\leq m-1$に対して($1^{\prime\prime}$)または($2^{\prime\prime}$)または($3^{\prime\prime}$)をみたす」となっている.
 ここまでの議論をまとめて「」で囲った2つの主張を合わせると,
 任意の$i\leq m$に対して
 \begin{itemize}
   \item[($1$)] $\varepsilon_m \in \SetOfSentenceSymbol$.
   \item[($2$)] $\exists j<m\big(\ \varepsilon_m=\mathcal{E}_{\lnot}( \varepsilon_j )\ \big)$.
   \item[($3$)] $\exists j,k<m\big(\ \varepsilon_m=\mathcal{E}_{\square}( \varepsilon_j, \varepsilon_k )\ \big)$.
     ここで$\square$は2項結合記号のいずれかを表す.
 \end{itemize}
 を満たしていることになり,
 これは$\ntuple{\varepsilon_1}{\varepsilon_m}$が構成列になっていることを表している.
\end{proof}

\begin{theorem}{帰納法の原理(E:p18 INDUCTION PRINCIPLE,\ K:p27 帰納法の原理)}
  \label{theorem:文論理における帰納法の原理}
 すべての文記号が属し,
 かつすべての式構成操作について閉じている整式の集合は,
 すべての整式からなる集合である.
\end{theorem}
\index{ぶんろんり@文論理!きのうほうのげんり@帰納法の原理}\index{sentential logic!Induction Principle}

証明の前にいくつか注意事項を書いておく
\begin{enumerate}
 \item
   定理の主張の条件をみたしている整式の集合を$\mathcal{A}$で表すことにすると,
   集合として$\mathcal{A} = \SetOfWff$を示すことが証明の目的となる.
   $\mathcal{A}\subseteq \SetOfWff$であることは明らかなので$\SetOfWff\subseteq \mathcal{A}$を示すだけでよい.
   部分集合の定義に戻ると,
   これは「任意の整式$\alpha$に対して$\alpha \in \mathcal{A}$」を示すことになったため,
   Example \ref{example:構成列}下の注意事項 \ref{remark:すべての整式に対しての構成の長さに関する証明の妥当性}にある通り,
   構成列の長さに関する帰納法,
   とくにこの場合は累積帰納法を用いて証明する.
 \item
   $\mathcal{A}$がすべての文記号が属するとは,
   論理式で書けば$A\in \SetOfSentenceSymbol( A \in \mathcal{A})$となる. \\
   また全ての式構成操作について閉じるということをもう少し厳密に見ると,
   $\mathcal{E}_{\lnot}$は$\SetOfExpression$上の1項演算,
   それ以外の式構成操作は$\SetOfExpression$上の2項演算であり,
   $\mathcal{A}\subseteq \SetOfExpression$である.
   たとえば$\mathcal{E}_{\lnot}\colon \SetOfExpression\to \SetOfExpression$について,
   この演算の$\mathcal{A}$への制限と考えることもできる.
   さらにこの$\mathcal{A}$は$\mathcal{E}_{\lnot}$について閉じている,
   つまり$\forall \alpha \in \mathcal{A}(\mathcal{E}_{\lnot}(\alpha)\in \mathcal{A})$と表すことができる.
   2項演算である$\mathcal{E}_{\land}$についても$\mathcal{A}$が$\mathcal{E}_{\land}$について閉じているとは,
   $\forall \alpha,\beta \in \mathcal{A}(\mathcal{E}_{\land}(\alpha,\beta)\in \mathcal{A})$と表すことができる.
   他の2項演算についても同様である.
\end{enumerate}

\begin{proof}
 証明すべきことは「任意にとった$n\in \mathbb{N}$と任意にとった構成列に対して,
 その構成列の長さが$n$ならば,
 その構成列に対する整式（構成列の末項）は$\mathcal{A}$に属する」である.
 任意にとる$n$に対して累積帰納法を用いて示す. \\
 任意に$n\in \mathbb{N}$をとる.
 帰納法の仮定は「長さが$n$未満であるような全ての構成列に対して,
 それに対応する整式が$\mathcal{A}$に属する」となる.
 いま長さ$n$な任意の構成列$\ntuple{\varepsilon_1}{\varepsilon_n}$をとる.
 この$\varepsilon_n$が$\mathcal{A}$に属することを示すことが目的である. \\
 構成列の定義から$\varepsilon_n$は以下のいずれかをみたす.
 \begin{itemize}
   \item[($1$)] $\varepsilon_n \in \SetOfSentenceSymbol$.
   \item[($2$)] $\exists j<n\big(\ \varepsilon_n=\mathcal{E}_{\lnot}( \varepsilon_j )\ \big)$.
   \item[($3$)] $\exists j,k<n\big(\ \varepsilon_n=\mathcal{E}_{\square}( \varepsilon_j, \varepsilon_k )\ \big)$.
     ここで$\square$は2項結合記号のいずれかを表す.
 \end{itemize}
 それぞれの場合について$\varepsilon_n\in \mathcal{A}$であることを示す.
 \begin{itemize}
   \item[($1$)] $\varepsilon_n \in \SetOfSentenceSymbol$のとき. \\
     整式$\varepsilon_n$は文記号一文字の整式であり,
     仮定より$\SetOfSentenceSymbol \subseteq \mathcal{A}$だから$\varepsilon_n\in \mathcal{A}$である.
   \item[($2$)] $\exists j<n\big(\ \varepsilon_n=\mathcal{E}_{\lnot}( \varepsilon_j )\ \big)$のとき. \\
     そのような$\varepsilon_j$を固定する.
     $\ntuple{\varepsilon_1}{\varepsilon_j}$は,
     構成列$\ntuple{\varepsilon_1}{\varepsilon_n}$の真の始切片であり,
     \PropRef{proposition:構成列の始切片は構成列}より構成列である.
     この構成列は$\varepsilon_j$に対応する構成列でその長さは$n$未満なので,
     帰納法の仮定より$\varepsilon_j\in \mathcal{A}$である.
     そして仮定より$\mathcal{E}_{\lnot}$が$\mathcal{A}$上閉じていることから$\mathcal{E}_{\lnot}( \varepsilon_j )\in \mathcal{A}$である.
     つまりこれは$\varepsilon_n\in \mathcal{A}$を表す.
   \item[($3$)] $\exists j,k<n\big(\ \varepsilon_n=\mathcal{E}_{\square}( \varepsilon_j, \varepsilon_k )\ \big)$（$\square$は2項結合記号のいずれか）のとき. \\
     たとえば$\square$を$\land$として,
     そんな$\varepsilon_j,\varepsilon_k$を固定する.
     $\ntuple{\varepsilon_1}{\varepsilon_j},\ntuple{\varepsilon_1}{\varepsilon_k}$は,
     構成列$\ntuple{\varepsilon_1}{\varepsilon_n}$の真の始切片であり,
     \PropRef{proposition:構成列の始切片は構成列}より構成列である.
     この2つの構成列はどちらも長さが$n$未満なので,
     帰納法の仮定より$\varepsilon_j,\varepsilon_k\in \mathcal{A}$である.
     そして仮定より$\mathcal{E}_{\land}$が$\mathcal{A}$上閉じていることから$\mathcal{E}_{\land}( \varepsilon_j, \varepsilon_k )\in \mathcal{A}$である.
     つまりこれは$\varepsilon_n\in \mathcal{A}$を表す. \\
     ほかの2項結合記号について同様である. \qedhere
 \end{itemize}
\end{proof}

この証明を構造的帰納法にて証明することも可能であるので確かめてみる.

\begin{proof}[Theorem \ref{theorem:文論理における帰納法の原理}の構造的帰納法による証明]
 Theorem \ref{theorem:文論理における帰納法の原理}の下に書いた注意事項を参考にして,
 $\SetOfWff\subseteq \mathcal{A}$,
 つまり任意に取った整式が$\mathcal{A}$に属することを示す.
 これについて構造的帰納法を用いる.
 \begin{itemize}
   \item[]\hspace{-0.5cm}（Basis） \\
     任意に文記号$A$をとる.
     仮定より$A\in \mathcal{A}$.
   \item[]\hspace{-0.5cm}（Induction step） \\
     任意に整式$\alpha,\beta$をとり,
     $\alpha,\beta\in \mathcal{A}$とする.
     仮定よりすべての式構成操作について$\mathcal{A}$が閉じているので
     $(\lnot \alpha), (\alpha \land \beta), (\alpha \lor \beta), (\alpha \to \beta), (\alpha \leftrightarrow \beta)$はすべて$\mathcal{A}$に属する. \qedhere
 \end{itemize}
\end{proof}

整式全体に関する定理の証明に対して帰納法の原理を使うことができる.

\begin{example}[E:p18 EXAMPLE,\ K:p28 例]
  \label{example:文論理の整式の両括弧の数は同じ}
 どの整式もそれに含まれる右括弧・左括弧の個数は同じである.
 \footnote{
   テキストでは「左括弧の数が右括弧の数より多い表現は整式ではない」となっていますが,
   実際に証明している,
   テキストにて証明末尾に書いてある主張は,
   同じ意味ではあるものの,
   ここに書いたものになっていたので,
   こちらに合わせました.
   この例は後で\LemRef{lemma:文論理の整式の両括弧の数は同じ}にて再度登場するけれど,
   そのときの主張の書き方はこちらの書き方に変わっているので,
   この書き方でも問題ないと思いました.
 }
\end{example}

\begin{proof}
 $\mathcal{A}$を含まれる両括弧記号の数が同じな整式の集合とする.
 $\mathcal{A}$が全ての整式の集合であることを示せばよい.
 以下の2点を示せば
 \begin{itemize}
   \item[1.] $\mathcal{A}$には全ての文記号（1つのみの整式）を含むこと
   \item[2.] $\mathcal{A}$は全ての式構成操作について閉じていること
 \end{itemize}
 \ThRef{theorem:文論理における帰納法の原理}より$\mathcal{A}=\SetOfWff$であることがわかる.
 \begin{itemize}
   \item[1.] （$\mathcal{A}$には全ての文記号（1つのみの整式）を含むこと） \\
     任意に$A\in \SetOfSentenceSymbol$をとる.
     $A$はそれぞれの括弧記号の数は0個,
     つまり両括弧記号の数は同じなので$A\in \mathcal{A}$である.
   \item[2.] （$\mathcal{A}$は全ての式構成操作について閉じていること） \\
     任意に$\alpha,\beta \in \mathcal{A}$をとり,
     それぞれの左括弧記号の個数を$k_{\alpha},k_{\beta}$とおくと,
     $\alpha,\beta \in \mathcal{A}$より右括弧記号の個数も$k_{\alpha},k_{\beta}$個である. \\
     $\mathcal{E}_{\lnot}(\alpha)=(\lnot \alpha)$より整式$\mathcal{E}_{\lnot}(\alpha)$の左右の括弧の数はどちらも$k_{\alpha}+1$となって,
     つまり両括弧記号の数は同じであるので,
     $\mathcal{E}_{\lnot}(\alpha)\in \mathcal{A}$である.
     つまり演算$\mathcal{E}_{\lnot}$について$\mathcal{A}$は閉じている. \\
     次に$\mathcal{E}_{\land}(\alpha,\beta)=(\alpha\land\beta)$より整式$\mathcal{E}_{\land}(\alpha,\beta)$の左右の括弧の数はどちらも$k_{\alpha}+k_{\beta}+1$となって,
     つまり両括弧記号の数は同じであるので,
     $\mathcal{E}_{\land}(\alpha,\beta)\in \mathcal{A}$である.
     つまり演算$\mathcal{E}_{\land}$について$\mathcal{A}$は閉じている.
     他の2項結合記号に関しても同様に証明できる. \qedhere
 \end{itemize}
\end{proof}

\subsection*{演習問題}
\label{subsection:「section：文論理の言語」演習問題}
\subfile{C:/souji/all-note/part/part_不完全性定理勉強会ノート/chapter_文論理/section_文論理の言語/subsection_「section：文論理の言語」演習問題.tex}

\end{document}
